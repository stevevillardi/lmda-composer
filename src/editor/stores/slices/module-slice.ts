/**
 * Module slice - manages module browser, search, commit, clone, and pull operations.
 * 
 * This slice handles:
 * - Module browser (listing and selecting modules from portal)
 * - Module search (searching scripts and datapoints across modules)
 * - Module commit (pushing script changes back to portal)
 * - Module clone (cloning modules to local git repository)
 * - Pull latest (pulling latest module version from portal)
 * - Repository browser
 */

import type { StateCreator } from 'zustand';
import type { 
  LogicModuleType,
  LogicModuleInfo,
  ModuleSearchMatchType,
  ScriptSearchResult,
  DataPointSearchResult,
  ModuleSearchProgress,
  ModuleIndexInfo,
  CloneResult,
  ScriptLanguage,
  ScriptMode,
  EditorTab,
  Portal,
  FetchModulesResponse,
} from '@/shared/types';
import { toast } from 'sonner';

// ============================================================================
// Types
// ============================================================================

/**
 * State managed by the module slice.
 */
export interface ModuleSliceState {
  // Module browser
  moduleBrowserOpen: boolean;
  selectedModuleType: LogicModuleType;
  modulesCache: Record<LogicModuleType, LogicModuleInfo[]>;
  modulesMeta: Record<LogicModuleType, { offset: number; hasMore: boolean; total: number }>;
  modulesSearch: Record<LogicModuleType, string>;
  isFetchingModules: boolean;
  selectedModule: LogicModuleInfo | null;
  moduleSearchQuery: string;

  // Module search
  moduleSearchOpen: boolean;
  moduleSearchMode: 'scripts' | 'datapoints';
  moduleSearchTerm: string;
  moduleSearchMatchType: ModuleSearchMatchType;
  moduleSearchCaseSensitive: boolean;
  moduleSearchModuleTypes: LogicModuleType[];
  isSearchingModules: boolean;
  moduleSearchProgress: ModuleSearchProgress | null;
  moduleSearchIndexInfo: ModuleIndexInfo | null;
  moduleSearchExecutionId: string | null;
  moduleScriptSearchResults: ScriptSearchResult[];
  moduleDatapointSearchResults: DataPointSearchResult[];
  moduleSearchError: string | null;
  selectedScriptSearchResult: ScriptSearchResult | null;
  selectedDatapointSearchResult: DataPointSearchResult | null;
  
  // Pending load confirmation state
  pendingModuleLoad: {
    script: string;
    language: ScriptLanguage;
    mode: ScriptMode;
  } | null;
  
  // Module commit state
  isCommittingModule: boolean;
  moduleCommitError: string | null;
  moduleCommitConfirmationOpen: boolean;
  loadedModuleForCommit: LogicModuleInfo | null;
  moduleCommitConflict: { hasConflict: boolean; message?: string; portalVersion?: number } | null;
  
  // Save options dialog (for portal documents)
  saveOptionsDialogOpen: boolean;
  saveOptionsDialogTabId: string | null;
  
  // Module clone to repository
  cloneModuleDialogOpen: boolean;
  
  // Pull latest from portal
  pullLatestDialogOpen: boolean;
  isPullingLatest: boolean;
  
  // Repository browser
  repositoryBrowserOpen: boolean;
}

/**
 * Actions provided by the module slice.
 */
export interface ModuleSliceActions {
  // Module browser actions
  setModuleBrowserOpen: (open: boolean) => void;
  setSelectedModuleType: (type: LogicModuleType) => void;
  fetchModules: (type: LogicModuleType, options?: { append?: boolean; search?: string; pages?: number }) => Promise<void>;
  setSelectedModule: (module: LogicModuleInfo | null) => void;
  setModuleSearchQuery: (query: string) => void;
  loadModuleScript: (script: string, language: ScriptLanguage, mode: ScriptMode) => void;
  confirmModuleLoad: () => void;
  cancelModuleLoad: () => void;
  
  // Module search actions
  setModuleSearchOpen: (open: boolean) => void;
  setModuleSearchMode: (mode: 'scripts' | 'datapoints') => void;
  setModuleSearchTerm: (query: string) => void;
  setModuleSearchMatchType: (matchType: ModuleSearchMatchType) => void;
  setModuleSearchCaseSensitive: (caseSensitive: boolean) => void;
  setModuleSearchModuleTypes: (moduleTypes: LogicModuleType[]) => void;
  searchModuleScripts: () => Promise<void>;
  searchDatapoints: () => Promise<void>;
  setSelectedScriptSearchResult: (result: ScriptSearchResult | null) => void;
  setSelectedDatapointSearchResult: (result: DataPointSearchResult | null) => void;
  clearModuleSearchResults: () => void;
  refreshModuleSearchIndex: () => Promise<void>;
  cancelModuleSearch: () => Promise<void>;
  
  // Module-specific tab actions (has portal dependencies)
  openModuleScripts: (module: LogicModuleInfo, scripts: Array<{ type: 'ad' | 'collection'; content: string }>) => void;
  
  // Module commit actions
  fetchModuleForCommit: (tabId: string) => Promise<void>;
  commitModuleScript: (tabId: string, reason?: string) => Promise<void>;
  canCommitModule: (tabId: string) => boolean;
  setModuleCommitConfirmationOpen: (open: boolean) => void;
  
  // Save options dialog
  setSaveOptionsDialogOpen: (open: boolean, tabId?: string) => void;
  
  // Module clone to repository actions
  setCloneModuleDialogOpen: (open: boolean) => void;
  cloneModuleToRepository: (tabId: string, repositoryId: string | null, overwrite?: boolean) => Promise<CloneResult>;
  canCloneModule: (tabId: string) => boolean;
  
  // Pull latest from portal actions
  setPullLatestDialogOpen: (open: boolean) => void;
  pullLatestFromPortal: (tabId: string) => Promise<{ success: boolean; error?: string }>;
  canPullLatest: (tabId: string) => boolean;
  
  // Repository browser
  setRepositoryBrowserOpen: (open: boolean) => void;
}

/**
 * Combined slice interface.
 */
export interface ModuleSlice extends ModuleSliceState, ModuleSliceActions {}

/**
 * Dependencies from other slices needed by ModuleSlice.
 */
export interface ModuleSliceDependencies {
  // From TabsSlice
  tabs: EditorTab[];
  activeTabId: string | null;
  openTab: (tabData: Partial<EditorTab> & Pick<EditorTab, 'displayName' | 'content' | 'language' | 'mode'>) => string;
  
  // From PortalSlice
  selectedPortalId: string | null;
  portals: Portal[];
}

// ============================================================================
// Initial State
// ============================================================================

const emptyModuleCache = {
  datasource: [],
  configsource: [],
  topologysource: [],
  propertysource: [],
  logsource: [],
  diagnosticsource: [],
  eventsource: [],
};

const emptyModuleMeta = {
  datasource: { offset: 0, hasMore: true, total: 0 },
  configsource: { offset: 0, hasMore: true, total: 0 },
  topologysource: { offset: 0, hasMore: true, total: 0 },
  propertysource: { offset: 0, hasMore: true, total: 0 },
  logsource: { offset: 0, hasMore: true, total: 0 },
  diagnosticsource: { offset: 0, hasMore: true, total: 0 },
  eventsource: { offset: 0, hasMore: true, total: 0 },
};

const emptyModuleSearch = {
  datasource: '',
  configsource: '',
  topologysource: '',
  propertysource: '',
  logsource: '',
  diagnosticsource: '',
  eventsource: '',
};

export const moduleSliceInitialState: ModuleSliceState = {
  // Module browser
  moduleBrowserOpen: false,
  selectedModuleType: 'datasource',
  modulesCache: emptyModuleCache,
  modulesMeta: emptyModuleMeta,
  modulesSearch: emptyModuleSearch,
  isFetchingModules: false,
  selectedModule: null,
  moduleSearchQuery: '',
  
  // Module search
  moduleSearchOpen: false,
  moduleSearchMode: 'scripts',
  moduleSearchTerm: '',
  moduleSearchMatchType: 'substring',
  moduleSearchCaseSensitive: false,
  moduleSearchModuleTypes: [
    'datasource',
    'configsource',
    'topologysource',
    'propertysource',
    'logsource',
    'diagnosticsource',
    'eventsource',
  ],
  isSearchingModules: false,
  moduleSearchProgress: null,
  moduleSearchIndexInfo: null,
  moduleSearchExecutionId: null,
  moduleScriptSearchResults: [],
  moduleDatapointSearchResults: [],
  moduleSearchError: null,
  selectedScriptSearchResult: null,
  selectedDatapointSearchResult: null,
  
  // Pending load confirmation
  pendingModuleLoad: null,
  
  // Module commit state
  isCommittingModule: false,
  moduleCommitError: null,
  moduleCommitConfirmationOpen: false,
  loadedModuleForCommit: null,
  moduleCommitConflict: null,
  
  // Save options dialog
  saveOptionsDialogOpen: false,
  saveOptionsDialogTabId: null,
  
  // Clone module
  cloneModuleDialogOpen: false,
  
  // Pull latest
  pullLatestDialogOpen: false,
  isPullingLatest: false,
  
  // Repository browser
  repositoryBrowserOpen: false,
};

// ============================================================================
// Module-level state for search listener management
// ============================================================================

let activeModuleSearchListener: ((message: unknown) => boolean) | null = null;

// ============================================================================
// Slice Creator
// ============================================================================

/**
 * Creates the module slice.
 */
export const createModuleSlice: StateCreator<
  ModuleSlice & ModuleSliceDependencies,
  [],
  [],
  ModuleSlice
> = (set, get) => ({
  ...moduleSliceInitialState,

  // ==========================================================================
  // Module Browser Actions
  // ==========================================================================

  setModuleBrowserOpen: (open) => {
    set({ moduleBrowserOpen: open });
    // Fetch modules for the selected type when opening
    if (open) {
      const { selectedModuleType, modulesCache, selectedPortalId } = get();
      if (selectedPortalId && modulesCache[selectedModuleType].length === 0) {
        get().fetchModules(selectedModuleType, { append: false, pages: 3, search: '' });
      }
    } else {
      // Clear selection when closing
      set({ selectedModule: null, moduleSearchQuery: '' });
    }
  },

  setSelectedModuleType: (type) => {
    set({ selectedModuleType: type, selectedModule: null });
    const { modulesCache, selectedPortalId } = get();
    // Fetch if cache is empty for this type
    if (selectedPortalId && modulesCache[type].length === 0) {
      get().fetchModules(type, { append: false, pages: 3, search: '' });
    }
  },

  fetchModules: async (type, options) => {
    const { selectedPortalId, modulesMeta, modulesSearch } = get();
    if (!selectedPortalId) return;

    const pages = Math.max(1, options?.pages ?? 1);
    if (pages > 1 && !options?.append) {
      for (let i = 0; i < pages; i++) {
        await get().fetchModules(type, {
          append: i > 0,
          search: options?.search ?? '',
          pages: 1,
        });
        if (!get().modulesMeta[type].hasMore) {
          break;
        }
      }
      return;
    }

    const append = options?.append ?? false;
    const search = options?.search ?? modulesSearch[type];
    const currentMeta = modulesMeta[type];
    const offset = append ? currentMeta.offset : 0;

    set({ isFetchingModules: true });

    try {
      const response = await chrome.runtime.sendMessage({
        type: 'FETCH_MODULES',
        payload: {
          portalId: selectedPortalId,
          moduleType: type,
          offset,
          size: 1000,
          search: search || undefined,
        },
      });

      if (response?.type === 'MODULES_FETCHED') {
        const fetchResponse = response.payload as FetchModulesResponse;
        set((state) => {
          const existing = append ? state.modulesCache[type] : [];
          const merged = new Map<number, LogicModuleInfo>();
          for (const item of existing) merged.set(item.id, item);
          for (const item of fetchResponse.items) merged.set(item.id, item);

          const nextOffset = offset + fetchResponse.items.length;

          return {
            modulesCache: {
              ...state.modulesCache,
              [type]: Array.from(merged.values()),
            },
            modulesMeta: {
              ...state.modulesMeta,
              [type]: {
                offset: nextOffset,
                hasMore: fetchResponse.hasMore,
                total: fetchResponse.total,
              },
            },
            modulesSearch: {
              ...state.modulesSearch,
              [type]: search,
            },
            isFetchingModules: false,
          };
        });
      } else {
        console.error('Failed to fetch modules:', response);
        toast.error('Failed to load modules', {
          description: 'Unable to fetch modules from the portal',
        });
        set({ isFetchingModules: false });
      }
    } catch (error) {
      console.error('Error fetching modules:', error);
      toast.error('Failed to load modules', {
        description: error instanceof Error ? error.message : 'Unknown error',
      });
      set({ isFetchingModules: false });
    }
  },

  setSelectedModule: (module) => {
    set({ selectedModule: module });
  },

  setModuleSearchQuery: (query) => {
    set({ moduleSearchQuery: query });
  },

  loadModuleScript: (script, language, mode) => {
    const { selectedModule, selectedPortalId, portals } = get();
    const portal = portals.find((entry) => entry.id === selectedPortalId);
    
    // Create a new tab for the loaded script
    const moduleName = selectedModule?.name || 'Module';
    const extension = language === 'groovy' ? 'groovy' : 'ps1';
    const modeLabel = mode === 'ad' ? 'ad' : mode === 'batchcollection' ? 'batch' : 'collection';
    const displayName = `${moduleName}/${modeLabel}.${extension}`;
    
    // Determine script type from mode
    const scriptType: 'collection' | 'ad' = mode === 'ad' ? 'ad' : 'collection';
    
    const newTab: EditorTab = {
      id: crypto.randomUUID(),
      displayName,
      content: script,
      language,
      mode,
      originalContent: script, // Store original content for dirty detection
      source: selectedModule ? {
        type: 'module',
        moduleId: selectedModule.id,
        moduleName: selectedModule.name,
        moduleType: selectedModule.moduleType,
        scriptType,
        lineageId: selectedModule.lineageId,
        portalId: selectedPortalId || undefined,
        portalHostname: portal?.hostname,
      } : undefined,
    };
    
    const { tabs } = get();
    set({
      tabs: [...tabs, newTab],
      activeTabId: newTab.id,
      moduleBrowserOpen: false,
      selectedModule: null,
      moduleSearchQuery: '',
      pendingModuleLoad: null,
    } as Partial<ModuleSlice & ModuleSliceDependencies>);
  },

  confirmModuleLoad: () => {
    const { pendingModuleLoad, selectedModule, selectedPortalId, portals } = get();
    if (!pendingModuleLoad) return;
    const portal = portals.find((entry) => entry.id === selectedPortalId);

    // Create a new tab for the loaded script
    const moduleName = selectedModule?.name || 'Module';
    const extension = pendingModuleLoad.language === 'groovy' ? 'groovy' : 'ps1';
    const modeLabel = pendingModuleLoad.mode === 'ad' ? 'ad' : pendingModuleLoad.mode === 'batchcollection' ? 'batch' : 'collection';
    const displayName = `${moduleName}/${modeLabel}.${extension}`;
    
    // Determine script type from mode
    const scriptType: 'collection' | 'ad' = pendingModuleLoad.mode === 'ad' ? 'ad' : 'collection';
    
    const newTab: EditorTab = {
      id: crypto.randomUUID(),
      displayName,
      content: pendingModuleLoad.script,
      language: pendingModuleLoad.language,
      mode: pendingModuleLoad.mode,
      originalContent: pendingModuleLoad.script, // Store original content for dirty detection
      source: selectedModule ? {
        type: 'module',
        moduleId: selectedModule.id,
        moduleName: selectedModule.name,
        moduleType: selectedModule.moduleType,
        scriptType,
        lineageId: selectedModule.lineageId,
        portalId: selectedPortalId || undefined,
        portalHostname: portal?.hostname,
      } : undefined,
    };
    
    const { tabs } = get();
    set({
      tabs: [...tabs, newTab],
      activeTabId: newTab.id,
      pendingModuleLoad: null,
      moduleBrowserOpen: false,
      selectedModule: null,
      moduleSearchQuery: '',
    } as Partial<ModuleSlice & ModuleSliceDependencies>);
  },

  cancelModuleLoad: () => {
    set({ pendingModuleLoad: null });
  },

  // ==========================================================================
  // Module Search Actions
  // ==========================================================================

  setModuleSearchOpen: (open) => {
    set({ moduleSearchOpen: open });
    if (!open) {
      set({
        moduleSearchTerm: '',
        moduleSearchError: null,
        moduleScriptSearchResults: [],
        moduleDatapointSearchResults: [],
        selectedScriptSearchResult: null,
        selectedDatapointSearchResult: null,
        isSearchingModules: false,
        moduleSearchProgress: null,
        moduleSearchExecutionId: null,
      });
    }
  },

  setModuleSearchMode: (mode) => {
    set({
      moduleSearchMode: mode,
      moduleSearchError: null,
      moduleScriptSearchResults: [],
      moduleDatapointSearchResults: [],
      selectedScriptSearchResult: null,
      selectedDatapointSearchResult: null,
      moduleSearchProgress: null,
    });
  },

  setModuleSearchTerm: (query) => {
    set({ moduleSearchTerm: query });
  },

  setModuleSearchMatchType: (matchType) => {
    set({ moduleSearchMatchType: matchType });
  },

  setModuleSearchCaseSensitive: (caseSensitive) => {
    set({ moduleSearchCaseSensitive: caseSensitive });
  },

  setModuleSearchModuleTypes: (moduleTypes) => {
    set({ moduleSearchModuleTypes: moduleTypes });
  },

  searchModuleScripts: async () => {
    const {
      selectedPortalId,
      moduleSearchTerm,
      moduleSearchMatchType,
      moduleSearchCaseSensitive,
      moduleSearchModuleTypes,
    } = get();
    if (!selectedPortalId) return;

    const trimmedQuery = moduleSearchTerm.trim();
    const previousSearchId = get().moduleSearchExecutionId;
    if (previousSearchId) {
      void chrome.runtime.sendMessage({
        type: 'CANCEL_MODULE_SEARCH',
        payload: { searchId: previousSearchId },
      }).catch(() => {
        // Ignore cancellation errors
      });
    }
    if (!trimmedQuery) {
      set({
        moduleScriptSearchResults: [],
        selectedScriptSearchResult: null,
        moduleSearchError: null,
        isSearchingModules: false,
        moduleSearchProgress: null,
      });
      return;
    }

    const searchId = crypto.randomUUID();
    set({
      isSearchingModules: true,
      moduleSearchError: null,
      moduleSearchExecutionId: searchId,
      moduleSearchProgress: { searchId, stage: 'searching', processed: 0, matched: 0 },
    });

    if (activeModuleSearchListener) {
      chrome.runtime.onMessage.removeListener(activeModuleSearchListener);
    }

    activeModuleSearchListener = (message: unknown) => {
      const msg = message as { type?: string; payload?: { searchId?: string } };
      if (msg.type === 'MODULE_SEARCH_PROGRESS' && msg.payload?.searchId === searchId) {
        set({ moduleSearchProgress: msg.payload as ModuleSearchProgress });
      }
      return false;
    };

    chrome.runtime.onMessage.addListener(activeModuleSearchListener);

    try {
      const response = await chrome.runtime.sendMessage({
        type: 'SEARCH_MODULE_SCRIPTS',
        payload: {
          portalId: selectedPortalId,
          query: trimmedQuery,
          matchType: moduleSearchMatchType,
          caseSensitive: moduleSearchCaseSensitive,
          moduleTypes: moduleSearchModuleTypes,
          searchId,
        },
      });

      const stillActive = get().moduleSearchExecutionId === searchId;
      if (!stillActive) {
        return;
      }

      if (response?.type === 'MODULE_SCRIPT_SEARCH_RESULTS') {
        const results = response.payload.results as ScriptSearchResult[];
        set({
          moduleScriptSearchResults: results,
          selectedScriptSearchResult: results[0] || null,
          isSearchingModules: false,
          moduleSearchProgress: null,
          moduleSearchExecutionId: null,
          moduleSearchIndexInfo: response.payload.indexInfo ?? null,
        });
      } else {
        const errorMessage = response?.payload?.error || 'Failed to search modules';
        set({
          moduleSearchError: errorMessage,
          isSearchingModules: false,
          moduleSearchProgress: null,
          moduleSearchExecutionId: null,
        });
      }
    } catch (error) {
      set({
        moduleSearchError: error instanceof Error ? error.message : 'Failed to search modules',
        isSearchingModules: false,
        moduleSearchProgress: null,
        moduleSearchExecutionId: null,
      });
    } finally {
      if (activeModuleSearchListener) {
        chrome.runtime.onMessage.removeListener(activeModuleSearchListener);
        activeModuleSearchListener = null;
      }
    }
  },

  searchDatapoints: async () => {
    const {
      selectedPortalId,
      moduleSearchTerm,
      moduleSearchMatchType,
      moduleSearchCaseSensitive,
    } = get();
    if (!selectedPortalId) return;

    const trimmedQuery = moduleSearchTerm.trim();
    const previousSearchId = get().moduleSearchExecutionId;
    if (previousSearchId) {
      void chrome.runtime.sendMessage({
        type: 'CANCEL_MODULE_SEARCH',
        payload: { searchId: previousSearchId },
      }).catch(() => {
        // Ignore cancellation errors
      });
    }
    if (!trimmedQuery) {
      set({
        moduleDatapointSearchResults: [],
        selectedDatapointSearchResult: null,
        moduleSearchError: null,
        isSearchingModules: false,
        moduleSearchProgress: null,
      });
      return;
    }

    const searchId = crypto.randomUUID();
    set({
      isSearchingModules: true,
      moduleSearchError: null,
      moduleSearchExecutionId: searchId,
      moduleSearchProgress: { searchId, stage: 'searching', processed: 0, matched: 0 },
    });

    if (activeModuleSearchListener) {
      chrome.runtime.onMessage.removeListener(activeModuleSearchListener);
    }

    activeModuleSearchListener = (message: unknown) => {
      const msg = message as { type?: string; payload?: { searchId?: string } };
      if (msg.type === 'MODULE_SEARCH_PROGRESS' && msg.payload?.searchId === searchId) {
        set({ moduleSearchProgress: msg.payload as ModuleSearchProgress });
      }
      return false;
    };

    chrome.runtime.onMessage.addListener(activeModuleSearchListener);

    try {
      const response = await chrome.runtime.sendMessage({
        type: 'SEARCH_DATAPOINTS',
        payload: {
          portalId: selectedPortalId,
          query: trimmedQuery,
          matchType: moduleSearchMatchType,
          caseSensitive: moduleSearchCaseSensitive,
          searchId,
        },
      });

      const stillActive = get().moduleSearchExecutionId === searchId;
      if (!stillActive) {
        return;
      }

      if (response?.type === 'DATAPOINT_SEARCH_RESULTS') {
        const results = response.payload.results as DataPointSearchResult[];
        set({
          moduleDatapointSearchResults: results,
          selectedDatapointSearchResult: results[0] || null,
          isSearchingModules: false,
          moduleSearchProgress: null,
          moduleSearchExecutionId: null,
          moduleSearchIndexInfo: response.payload.indexInfo ?? null,
        });
      } else {
        const errorMessage = response?.payload?.error || 'Failed to search datapoints';
        set({
          moduleSearchError: errorMessage,
          isSearchingModules: false,
          moduleSearchProgress: null,
          moduleSearchExecutionId: null,
        });
      }
    } catch (error) {
      set({
        moduleSearchError: error instanceof Error ? error.message : 'Failed to search datapoints',
        isSearchingModules: false,
        moduleSearchProgress: null,
        moduleSearchExecutionId: null,
      });
    } finally {
      if (activeModuleSearchListener) {
        chrome.runtime.onMessage.removeListener(activeModuleSearchListener);
        activeModuleSearchListener = null;
      }
    }
  },

  setSelectedScriptSearchResult: (result) => {
    set({ selectedScriptSearchResult: result });
  },

  setSelectedDatapointSearchResult: (result) => {
    set({ selectedDatapointSearchResult: result });
  },

  clearModuleSearchResults: () => {
    set({
      moduleScriptSearchResults: [],
      moduleDatapointSearchResults: [],
      selectedScriptSearchResult: null,
      selectedDatapointSearchResult: null,
      moduleSearchError: null,
      moduleSearchProgress: null,
    });
  },

  refreshModuleSearchIndex: async () => {
    const { selectedPortalId } = get();
    if (!selectedPortalId) return;

    const previousSearchId = get().moduleSearchExecutionId;
    if (previousSearchId) {
      void chrome.runtime.sendMessage({
        type: 'CANCEL_MODULE_SEARCH',
        payload: { searchId: previousSearchId },
      }).catch(() => {
        // Ignore cancellation errors
      });
    }

    const searchId = crypto.randomUUID();
    set({
      moduleSearchProgress: { searchId, stage: 'indexing', processed: 0 },
      moduleSearchExecutionId: searchId,
      moduleSearchError: null,
    });

    if (activeModuleSearchListener) {
      chrome.runtime.onMessage.removeListener(activeModuleSearchListener);
    }

    activeModuleSearchListener = (message: unknown) => {
      const msg = message as { type?: string; payload?: { searchId?: string } };
      if (msg.type === 'MODULE_SEARCH_PROGRESS' && msg.payload?.searchId === searchId) {
        set({ moduleSearchProgress: msg.payload as ModuleSearchProgress });
      }
      return false;
    };

    chrome.runtime.onMessage.addListener(activeModuleSearchListener);

    try {
      const response = await chrome.runtime.sendMessage({
        type: 'REFRESH_MODULE_INDEX',
        payload: { portalId: selectedPortalId, searchId },
      });

      if (response?.type === 'MODULE_INDEX_REFRESHED') {
        set({
          moduleSearchIndexInfo: response.payload as ModuleIndexInfo,
          moduleSearchProgress: null,
          moduleSearchExecutionId: null,
        });
        toast.success('Module search index refreshed');
      } else if (response?.type === 'MODULE_SCRIPT_SEARCH_ERROR') {
        set({
          moduleSearchError: response.payload?.error || 'Failed to refresh module index',
          moduleSearchProgress: null,
          moduleSearchExecutionId: null,
        });
      } else {
        set({
          moduleSearchError: 'Failed to refresh module index',
          moduleSearchProgress: null,
          moduleSearchExecutionId: null,
        });
      }
    } catch (error) {
      set({
        moduleSearchError: error instanceof Error ? error.message : 'Failed to refresh module index',
        moduleSearchProgress: null,
        moduleSearchExecutionId: null,
      });
    } finally {
      if (activeModuleSearchListener) {
        chrome.runtime.onMessage.removeListener(activeModuleSearchListener);
        activeModuleSearchListener = null;
      }
    }
  },

  cancelModuleSearch: async () => {
    const { moduleSearchExecutionId } = get();
    if (!moduleSearchExecutionId) return;

    try {
      await chrome.runtime.sendMessage({
        type: 'CANCEL_MODULE_SEARCH',
        payload: { searchId: moduleSearchExecutionId },
      });
    } catch (error) {
      console.error('Failed to cancel module search:', error);
    } finally {
      set({
        isSearchingModules: false,
        moduleSearchExecutionId: null,
        moduleSearchProgress: null,
      });
      if (activeModuleSearchListener) {
        chrome.runtime.onMessage.removeListener(activeModuleSearchListener);
        activeModuleSearchListener = null;
      }
    }
  },

  // ==========================================================================
  // Module-Specific Tab Actions
  // ==========================================================================

  openModuleScripts: (module, scripts) => {
    const { tabs, selectedPortalId, portals } = get();
    const extension = module.scriptType === 'powerShell' ? 'ps1' : 'groovy';
    const language: ScriptLanguage = module.scriptType === 'powerShell' ? 'powershell' : 'groovy';
    const portal = portals.find((entry) => entry.id === selectedPortalId);
    
    const newTabs: EditorTab[] = [];
    
    for (const script of scripts) {
      const modeLabel = script.type === 'ad' ? 'AD' : 'Collection';
      const displayName = `${module.name} (${modeLabel}).${extension}`;
      
      // Determine proper mode based on script type
      const mode: ScriptMode = script.type === 'ad' ? 'ad' : 'collection';
      
      const newTab: EditorTab = {
        id: crypto.randomUUID(),
        displayName,
        content: script.content,
        language,
        mode,
        originalContent: script.content, // For dirty detection
        source: {
          type: 'module',
          moduleId: module.id,
          moduleName: module.name,
          moduleType: module.moduleType,
          scriptType: script.type,
          lineageId: module.lineageId,
          portalId: selectedPortalId || undefined,
          portalHostname: portal?.hostname,
        },
      };
      
      newTabs.push(newTab);
    }
    
    if (newTabs.length > 0) {
      set({
        tabs: [...tabs, ...newTabs],
        activeTabId: newTabs[0].id,
        moduleBrowserOpen: false,
        selectedModule: null,
        moduleSearchQuery: '',
      } as Partial<ModuleSlice & ModuleSliceDependencies>);
    }
  },

  // ==========================================================================
  // Module Commit Actions (Placeholders - implementation in editor-store)
  // ==========================================================================

  fetchModuleForCommit: async () => {
    // Placeholder - actual implementation remains in editor-store.ts 
    // due to complex dependencies on file operations
  },

  commitModuleScript: async () => {
    // Placeholder - actual implementation remains in editor-store.ts
    // due to complex dependencies on file operations and API calls
  },

  canCommitModule: (tabId: string) => {
    const { tabs } = get();
    const tab = tabs.find(t => t.id === tabId);
    if (!tab) return false;
    if (tab.source?.type !== 'module') return false;
    if (!tab.source.portalId) return false;
    return true;
  },

  setModuleCommitConfirmationOpen: (open: boolean) => {
    set({ moduleCommitConfirmationOpen: open });
  },

  // ==========================================================================
  // Save Options Dialog
  // ==========================================================================

  setSaveOptionsDialogOpen: (open: boolean, tabId?: string) => {
    set({ 
      saveOptionsDialogOpen: open, 
      saveOptionsDialogTabId: tabId ?? null,
    });
  },

  // ==========================================================================
  // Module Clone to Repository Actions (Placeholders)
  // ==========================================================================

  setCloneModuleDialogOpen: (open: boolean) => {
    set({ cloneModuleDialogOpen: open });
  },

  cloneModuleToRepository: async () => {
    // Placeholder - actual implementation remains in editor-store.ts
    // due to complex dependencies on document-store and file operations
    return { 
      success: false, 
      error: 'Not implemented in slice - see editor-store.ts',
      repositoryId: '',
      modulePath: '',
      fileIds: {},
    };
  },

  canCloneModule: (tabId: string) => {
    const { tabs } = get();
    const tab = tabs.find(t => t.id === tabId);
    if (!tab) return false;
    if (tab.source?.type !== 'module') return false;
    if (!tab.source.portalId) return false;
    return true;
  },

  // ==========================================================================
  // Pull Latest from Portal Actions (Placeholders)
  // ==========================================================================

  setPullLatestDialogOpen: (open: boolean) => {
    set({ pullLatestDialogOpen: open });
  },

  pullLatestFromPortal: async () => {
    // Placeholder - actual implementation remains in editor-store.ts
    // due to complex dependencies on document-store and API calls
    return { success: false, error: 'Not implemented in slice - see editor-store.ts' };
  },

  canPullLatest: (tabId: string) => {
    const { tabs } = get();
    const tab = tabs.find(t => t.id === tabId);
    if (!tab) return false;
    if (tab.source?.type !== 'module') return false;
    if (!tab.source.portalId) return false;
    return true;
  },

  // ==========================================================================
  // Repository Browser
  // ==========================================================================

  setRepositoryBrowserOpen: (open: boolean) => {
    set({ repositoryBrowserOpen: open });
  },
});
