---
title: Execution Modes
description: Understanding Freeform, Active Discovery, Collection, and Batch Collection modes.
---

import { Card, CardGrid, Tabs, TabItem, Aside, Badge, LinkCard } from '@astrojs/starlight/components';
import { Icon } from '@astrojs/starlight/components';
import ModeCard from '../../../components/ModeCard.astro';

LMDA Composer supports four execution modes, each designed for different LogicModule scripting scenarios. The selected mode determines how output is parsed and validated.

{/* Screenshot placeholder */}
<div class="screenshot-placeholder" style="background: var(--sl-color-gray-6); border: 2px dashed var(--sl-color-gray-4); border-radius: 0.5rem; padding: 2rem; text-align: center; margin: 1rem 0;">
  <Icon name="image" size="1.5rem" />
  <p style="margin: 0.5rem 0 0 0; color: var(--sl-color-gray-3); font-size: 0.8rem;">
    Screenshot: mode-selector.png<br />
    <em>Toolbar showing mode dropdown with all options</em>
  </p>
</div>

---

<ModeCard mode="freeform" title="General Scripting & Testing">
  **Best for:** Testing, debugging, and exploration without output validation.

  Freeform mode runs your script without any output format requirements. Use it when:

  - Testing API calls or data retrieval
  - Debugging script logic step-by-step
  - Running maintenance or utility scripts
  - Exploring collector capabilities

  ```groovy
  // Freeform example - just print output
  def devices = Snmp.walk("192.168.1.1", "1.3.6.1.2.1.1")
  devices.each { oid, value ->
      println "${oid} = ${value}"
  }
  return 0
  ```

  In Freeform mode:
  - **Parsed** and **Validation** tabs are disabled
  - Only **Raw Output** is available
  - No format requirements apply
</ModeCard>

---

<ModeCard mode="ad" title="Instance Discovery">
  **Best for:** Writing and testing Active Discovery (AD) scripts for DataSources.

  Active Discovery scripts return instance data that LogicMonitor uses to create monitoring instances.

  ### Output Format

  Each line represents one discovered instance:

  ```
  instance_id##instance_name
  instance_id##instance_name##description
  instance_id##instance_name##description####prop1=value1&prop2=value2
  ```

  | Field | Required | Max Length | Rules |
  |-------|----------|------------|-------|
  | Instance ID | <Badge text="Required" variant="caution" /> | 1024 chars | No spaces, `=`, `:`, `\`, or `#` |
  | Instance Name | <Badge text="Required" variant="caution" /> | 255 chars | Display name for the instance |
  | Description | <Badge text="Optional" variant="note" /> | — | Optional description text |
  | Properties | <Badge text="Optional" variant="note" /> | — | Auto-properties as `key=value&key=value` |

  ### Example Script

  ```groovy
  // Discover network interfaces
  def host = hostProps.get("system.hostname")
  def interfaces = Snmp.walk(host, "1.3.6.1.2.1.2.2.1.2")

  interfaces.each { oid, name ->
      def index = oid.tokenize('.')[-1]
      // Format: id##name##description####auto.props
      println "${index}##${name}##Interface ${index}####auto.interface.index=${index}"
  }

  return 0
  ```

  ### Validation Checks

  The **Validation** tab reports:
  - ✅ Valid instances with all required fields
  - ❌ Invalid instance IDs (empty, too long, invalid characters)
  - ⚠️ Warnings for instance names exceeding 255 characters
  - Total instance count in the tab header
</ModeCard>

---

<ModeCard mode="collection" title="Single-Instance Metrics">
  **Best for:** Writing collection scripts for single-instance DataSources.

  Collection scripts output datapoint values as simple key-value pairs:

  ```
  datapoint_name=numeric_value
  ```

  ### Example Script

  ```groovy
  // Collect CPU metrics
  def host = hostProps.get("system.hostname")
  def cpuOid = "1.3.6.1.2.1.25.3.3.1.2"
  def cpuValues = Snmp.walk(host, cpuOid)

  def total = 0
  def count = 0
  cpuValues.each { oid, value ->
      total += value.toInteger()
      count++
  }

  println "CpuUsage=${count > 0 ? total / count : 0}"
  println "CpuCount=${count}"

  return 0
  ```

  ### Validation Rules

  | Rule | Severity |
  |------|----------|
  | Must be `key=value` format | <Badge text="Error" variant="danger" /> |
  | Value must be numeric | <Badge text="Error" variant="danger" /> |
  | Invalid datapoint name characters | <Badge text="Warning" variant="caution" /> |
  | Non-matching lines ignored | <Badge text="Warning" variant="caution" /> |
</ModeCard>

---

<ModeCard mode="batch" title="Multi-Instance Metrics">
  **Best for:** Writing batch collection scripts that handle multiple instances in a single execution.

  Batch scripts output data for all instances at once, prefixed with the instance ID (wildvalue):

  ```
  wildvalue.datapoint=numeric_value
  ```

  ### Example Script

  ```groovy
  // Batch collect for all interfaces
  def host = hostProps.get("system.hostname")
  def instances = datasourceinstanceProps.keySet()

  instances.each { wildvalue ->
      def inOctets = Snmp.get(host, "1.3.6.1.2.1.2.2.1.10.${wildvalue}")
      def outOctets = Snmp.get(host, "1.3.6.1.2.1.2.2.1.16.${wildvalue}")
      
      println "${wildvalue}.InOctets=${inOctets}"
      println "${wildvalue}.OutOctets=${outOctets}"
  }

  return 0
  ```

  ### Execution Context

  When running in **Collection** or **Batch Collection** mode, a dialog prompts for additional context:

  - **Collection Mode**: Enter the `wildvalue` (instance ID) to simulate
  - **Batch Mode**: Enter the `datasourceId` to load all instance properties

  This populates `instanceProps` (Collection) or `datasourceinstanceProps` (Batch) for your script.

  ### Validation Rules

  Same rules as Collection mode, plus:
  - Wildvalue prefix is required on each line
  - Wildvalue follows instance ID rules (no spaces, `=`, `:`, `\`, `#`)
  - Maximum 1024 characters for wildvalue
</ModeCard>

---

## Choosing the Right Mode

<Tabs>
  <TabItem label="By Task" icon="rocket">
    | Task | Recommended Mode |
    |------|------------------|
    | Testing SNMP/WMI queries | Freeform |
    | Building discovery logic | Active Discovery |
    | Single-instance DataSource | Collection |
    | Multi-instance DataSource | Batch Collection |
    | PropertySource script | Freeform |
    | Debugging any script | Freeform |
  </TabItem>
  
  <TabItem label="By Module Type" icon="document">
    | Module Type | Primary Mode |
    |-------------|--------------|
    | DataSource (AD script) | Active Discovery |
    | DataSource (Collect script) | Collection or Batch |
    | ConfigSource | Collection |
    | PropertySource | Freeform |
    | EventSource | Freeform |
    | TopologySource | Freeform (Graph tab) |
  </TabItem>
</Tabs>

---

## Mode Indicators

The current mode is displayed in multiple locations:

<CardGrid>
  <Card title="Toolbar" icon="setting">
    Mode selector dropdown shows the active mode with its icon.
  </Card>
  <Card title="Status Bar" icon="information">
    Mode badge at the bottom of the window.
  </Card>
  <Card title="Tab Bar" icon="open-book">
    Each tab shows its mode—switch tabs to switch modes.
  </Card>
</CardGrid>

<Aside type="tip" title="Per-Tab Modes">
  Each tab remembers its own mode setting. Work on AD and Collection scripts simultaneously without switching modes manually.
</Aside>

---

## Next Steps

<LinkCard
  title="Output Panel"
  description="Learn how to interpret parsed output and validation results."
  href="/lmda-composer/core-features/output-panel/"
/>



